{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"name\", \"size\", \"color\", \"style\", \"children\", \"allowFontScaling\", \"innerRef\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport React, { forwardRef } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport PixelRatio from \"react-native-web/dist/exports/PixelRatio\";\nimport processColor from \"react-native-web/dist/exports/processColor\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport ensureNativeModuleAvailable from \"./ensure-native-module-available\";\nimport createIconSourceCache from \"./create-icon-source-cache\";\nimport NativeIconAPI from \"./NativeVectorIcons\";\nexport var DEFAULT_ICON_SIZE = 12;\nexport var DEFAULT_ICON_COLOR = 'black';\nexport var createIconSet = function createIconSet(glyphMap, fontFamily, fontFile, fontStyle) {\n  var fontBasename = fontFile ? fontFile.replace(/\\.(otf|ttf)$/, '') : fontFamily;\n  var fontReference = Platform.select({\n    windows: `/Assets/${fontFile}#${fontFamily}`,\n    android: fontBasename,\n    web: fontBasename,\n    default: fontFamily\n  });\n  var resolveGlyph = function resolveGlyph(name) {\n    var glyph = glyphMap[name] || '?';\n    if (typeof glyph === 'number') {\n      return String.fromCodePoint(glyph);\n    }\n    return glyph;\n  };\n  var Icon = function Icon(_ref) {\n    var name = _ref.name,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? DEFAULT_ICON_SIZE : _ref$size,\n      color = _ref.color,\n      style = _ref.style,\n      children = _ref.children,\n      _ref$allowFontScaling = _ref.allowFontScaling,\n      allowFontScaling = _ref$allowFontScaling === void 0 ? false : _ref$allowFontScaling,\n      innerRef = _ref.innerRef,\n      props = _objectWithoutProperties(_ref, _excluded);\n    var glyph = name ? resolveGlyph(name) : '';\n    var styleDefaults = {\n      fontSize: size,\n      color: color\n    };\n    var styleOverrides = {\n      fontFamily: fontReference,\n      fontWeight: 'normal',\n      fontStyle: 'normal'\n    };\n    var newProps = _objectSpread(_objectSpread({}, props), {}, {\n      style: [styleDefaults, style, styleOverrides, fontStyle || {}],\n      allowFontScaling: allowFontScaling\n    });\n    return React.createElement(Text, _extends({\n      ref: innerRef,\n      selectable: false\n    }, newProps), glyph, children);\n  };\n  var WrappedIcon = forwardRef(function (props, ref) {\n    return React.createElement(Icon, _extends({\n      innerRef: ref\n    }, props));\n  });\n  WrappedIcon.displayName = 'Icon';\n  var imageSourceCache = createIconSourceCache();\n  var getImageSourceSync = function getImageSourceSync(name) {\n    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ICON_SIZE;\n    var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ICON_COLOR;\n    ensureNativeModuleAvailable();\n    var glyph = resolveGlyph(name);\n    var processedColor = processColor(color);\n    var cacheKey = `${glyph}:${size}:${String(processedColor)}`;\n    if (imageSourceCache.has(cacheKey)) {\n      return imageSourceCache.get(cacheKey);\n    }\n    try {\n      var imagePath = NativeIconAPI.getImageForFontSync(fontReference, glyph, size, processedColor);\n      var value = {\n        uri: imagePath,\n        scale: PixelRatio.get()\n      };\n      imageSourceCache.setValue(cacheKey, value);\n      return value;\n    } catch (error) {\n      imageSourceCache.setError(cacheKey, error);\n      throw error;\n    }\n  };\n  var getImageSource = function () {\n    var _ref2 = _asyncToGenerator(function* (name) {\n      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ICON_SIZE;\n      var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_ICON_COLOR;\n      ensureNativeModuleAvailable();\n      var glyph = resolveGlyph(name);\n      var processedColor = processColor(color);\n      var cacheKey = `${glyph}:${size}:${String(processedColor)}`;\n      if (imageSourceCache.has(cacheKey)) {\n        return imageSourceCache.get(cacheKey);\n      }\n      try {\n        var imagePath = yield NativeIconAPI.getImageForFont(fontReference, glyph, size, processedColor);\n        var value = {\n          uri: imagePath,\n          scale: PixelRatio.get()\n        };\n        imageSourceCache.setValue(cacheKey, value);\n        return value;\n      } catch (error) {\n        imageSourceCache.setError(cacheKey, error);\n        throw error;\n      }\n    });\n    return function getImageSource(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var loadFont = function () {\n    var _ref3 = _asyncToGenerator(function* () {\n      if (Platform.OS !== 'ios') {\n        return;\n      }\n      ensureNativeModuleAvailable();\n      var _fontFile$split = fontFile.split('.'),\n        _fontFile$split2 = _slicedToArray(_fontFile$split, 2),\n        filename = _fontFile$split2[0],\n        extension = _fontFile$split2[1];\n      if (!extension) {\n        throw new Error('Font needs a filename extensison.');\n      }\n      yield NativeIconAPI.loadFontWithFileName(filename, extension, 'react-native-vector-icons');\n    });\n    return function loadFont() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  loadFont();\n  var IconNamespace = Object.assign(WrappedIcon, {\n    getImageSource: getImageSource,\n    getImageSourceSync: getImageSourceSync\n  });\n  return IconNamespace;\n};","map":{"version":3,"names":["React","forwardRef","Platform","PixelRatio","processColor","Text","ensureNativeModuleAvailable","createIconSourceCache","NativeIconAPI","DEFAULT_ICON_SIZE","DEFAULT_ICON_COLOR","createIconSet","glyphMap","fontFamily","fontFile","fontStyle","fontBasename","replace","fontReference","select","windows","android","web","default","resolveGlyph","name","glyph","String","fromCodePoint","Icon","_ref","_ref$size","size","color","style","children","_ref$allowFontScaling","allowFontScaling","innerRef","props","_objectWithoutProperties","_excluded","styleDefaults","fontSize","styleOverrides","fontWeight","newProps","_objectSpread","createElement","_extends","ref","selectable","WrappedIcon","displayName","imageSourceCache","getImageSourceSync","arguments","length","undefined","processedColor","cacheKey","has","get","imagePath","getImageForFontSync","value","uri","scale","setValue","error","setError","getImageSource","_ref2","_asyncToGenerator","getImageForFont","_x","apply","loadFont","_ref3","OS","_fontFile$split","split","_fontFile$split2","_slicedToArray","filename","extension","Error","loadFontWithFileName","IconNamespace","Object","assign"],"sources":["C:\\Users\\786\\Desktop\\Chat-App\\my-app\\node_modules\\@react-native-vector-icons\\common\\src\\create-icon-set.tsx"],"sourcesContent":["import React, { forwardRef, type Ref } from 'react';\n\nimport {\n  Platform,\n  PixelRatio,\n  processColor,\n  Text,\n  type TextProps,\n  type TextStyle,\n} from 'react-native';\n\nimport ensureNativeModuleAvailable from './ensure-native-module-available';\nimport createIconSourceCache from './create-icon-source-cache';\nimport NativeIconAPI from './NativeVectorIcons';\n\nexport const DEFAULT_ICON_SIZE = 12;\nexport const DEFAULT_ICON_COLOR = 'black';\n\nexport type IconProps<T> = TextProps & {\n  name: T;\n  size?: number;\n  color?: TextStyle['color'];\n  innerRef?: Ref<Text>;\n};\n\nexport const createIconSet = <GM extends Record<string, number>>(\n  glyphMap: GM,\n  fontFamily: string,\n  fontFile: string,\n  fontStyle?: TextProps['style']\n) => {\n  // Android doesn't care about actual fontFamily name, it will only look in fonts folder.\n  const fontBasename = fontFile\n    ? fontFile.replace(/\\.(otf|ttf)$/, '')\n    : fontFamily;\n\n  const fontReference = Platform.select({\n    windows: `/Assets/${fontFile}#${fontFamily}`,\n    android: fontBasename,\n    web: fontBasename,\n    default: fontFamily,\n  });\n\n  const resolveGlyph = (name: keyof GM) => {\n    const glyph = glyphMap[name] || '?';\n\n    if (typeof glyph === 'number') {\n      return String.fromCodePoint(glyph);\n    }\n\n    return glyph;\n  };\n\n  const Icon = ({\n    name,\n    size = DEFAULT_ICON_SIZE,\n    color,\n    style,\n    children,\n    allowFontScaling = false,\n    innerRef,\n    ...props\n  }: IconProps<keyof GM>) => {\n    const glyph = name ? resolveGlyph(name as string) : '';\n\n    const styleDefaults = {\n      fontSize: size,\n      color,\n    };\n\n    const styleOverrides: TextProps['style'] = {\n      fontFamily: fontReference,\n      fontWeight: 'normal',\n      fontStyle: 'normal',\n    };\n\n    const newProps: TextProps = {\n      ...props,\n      style: [styleDefaults, style, styleOverrides, fontStyle || {}],\n      allowFontScaling,\n    };\n\n    return (\n      <Text ref={innerRef} selectable={false} {...newProps}>\n        {glyph}\n        {children}\n      </Text>\n    );\n  };\n\n  const WrappedIcon = forwardRef<Text, IconProps<keyof typeof glyphMap>>((props, ref) => <Icon innerRef={ref} {...props} />);\n  WrappedIcon.displayName = 'Icon';\n\n  const imageSourceCache = createIconSourceCache();\n\n  const getImageSourceSync = (\n    name: keyof GM,\n    size = DEFAULT_ICON_SIZE,\n    color: TextStyle['color'] = DEFAULT_ICON_COLOR\n  ) => {\n    ensureNativeModuleAvailable();\n\n    const glyph = resolveGlyph(name);\n    const processedColor = processColor(color);\n    const cacheKey = `${glyph}:${size}:${String(processedColor)}`;\n\n    if (imageSourceCache.has(cacheKey)) {\n      // FIXME: Should this check if it's an error and throw it again?\n      return imageSourceCache.get(cacheKey);\n    }\n\n    try {\n      const imagePath =\n        NativeIconAPI.getImageForFontSync(\n          fontReference,\n          glyph,\n          size,\n          processedColor as number // FIXME what if a non existant colour was passed in?\n        );\n      const value = { uri: imagePath, scale: PixelRatio.get() };\n      imageSourceCache.setValue(cacheKey, value);\n      return value;\n    } catch (error) {\n      imageSourceCache.setError(cacheKey, error as Error);\n      throw error;\n    }\n  };\n\n  const getImageSource = async (\n    name: keyof GM,\n    size = DEFAULT_ICON_SIZE,\n    color: TextStyle['color'] = DEFAULT_ICON_COLOR\n  ) => {\n    ensureNativeModuleAvailable();\n\n    const glyph = resolveGlyph(name);\n    const processedColor = processColor(color);\n    const cacheKey = `${glyph}:${size}:${String(processedColor)}`;\n\n    if (imageSourceCache.has(cacheKey)) {\n      // FIXME: Should this check if it's an error and throw it again?\n      return imageSourceCache.get(cacheKey);\n    }\n\n    try {\n      const imagePath = await NativeIconAPI.getImageForFont(\n        fontReference,\n        glyph,\n        size,\n        processedColor as number // FIXME what if a non existant colour was passed in?\n      );\n      const value = { uri: imagePath, scale: PixelRatio.get() };\n      imageSourceCache.setValue(cacheKey, value);\n      return value;\n    } catch (error) {\n      imageSourceCache.setError(cacheKey, error as Error);\n      throw error;\n    }\n  };\n\n  const loadFont = async () => {\n    if (Platform.OS !== 'ios') {\n      return;\n    }\n    ensureNativeModuleAvailable();\n\n    const [filename, extension] = fontFile.split('.'); // FIXME: what if filename has two dots?\n    if (!extension) {\n      throw new Error('Font needs a filename extensison.');\n    }\n\n    await NativeIconAPI.loadFontWithFileName(filename!, extension, 'react-native-vector-icons');\n  };\n\n  loadFont();\n\n  const IconNamespace = Object.assign(WrappedIcon, {\n    getImageSource: getImageSource,\n    getImageSourceSync: getImageSourceSync,\n  });\n\n  return IconNamespace;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}